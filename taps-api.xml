<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="info" docName="...." ipr="trust200902">
    <front>
        <title abbrev="Transport Services API">
            Transport Services for Low-Latency Applications
        </title>

        <author fullname="Stephen McQuistin" initials="S." surname="McQuistin">
            <organization>University of Glasgow</organization>
            <address>
                <postal>
                    <street>School of Computing Science</street>
                    <city>Glasgow</city>
                    <code>G12 8QQ</code>
                    <country>UK</country>
                </postal>
                <email>sm@smcquistin.uk</email>
            </address>
        </author>

        <author fullname="Colin Perkins" initials="C. S." surname="Perkins">
            <organization>University of Glasgow</organization>
            <address>
                <postal>
                    <street>School of Computing Science</street>
                    <city>Glasgow</city>
                    <code>G12 8QQ</code><country>UK</country>
                </postal>
                <email>csp@csperkins.org</email>
            </address>
        </author>

        <date year="2016" />

        <area>Transport</area>

        <workgroup>TAPS Working Group</workgroup>

        <abstract>
            <t>
                This document describes the set of transport services required
                by low-latency applications. These services are derived
                from the needs of the application, rather than from the
                current capabilities of the transport layer. An example
                API, based on the BSD Sockets API, is also given.
            </t>
        </abstract>
    </front>

    <middle>
        <section anchor="Introduction" title="Introduction">
            <t>
                The goal of the TAPS working group is to break down the
                existing transport layer into a set of transport services,
                decoupling these from the transport protocols that provide
                them. As a result, the standardisation of transport
                services becomes feasible and important. The first phase of
                this has been to inspect the existing transport protocols,
                and determine the services they provide. The next phase,
                enabled both by the use of transport services and their
                separation from transport protocols, is to define novel
                transport services based on the needs of applications.
                In essence, these services are derived from applications by
                thinking about what the transport layer would provide to
                applications if the constraints of the existing transport
                protocols were not in place.
            </t>
            <t>
                This document considers the transport services required by
                low-latency applications. This is an important class of
                applications, not only because it represents a significant
                portion of Internet traffic, but because it is arguably
                poorly served by the existing transport layer: the
                available transport protocols bundle together transport
                services in such a way that no one protocol is ideal.
            </t>
            <t>
                After detailing the transport services required by these
                applications, a sample API that provides these services is
                outlined. This API is then used to demonstrate how
                applications might make use of the transport services
                described.
            </t>
            <t>
                This document does not consider how the transport services
                described map to the transport protocols that might provide
                them.
            </t>
        </section>

        <section anchor="Services" title="Application-derived Transport Services">
            <t>
                It is important that the transport services supported by
                a new API are derived from the needs of the applications
                that will use it. This sections describes a list of the
                transport services required by applications.
            </t>
            <section anchor="Timing" title="Timing &amp; deadlines">
                <t>
                    The data conveyed by low-latency applications has some
                    notion of a deadline, relative to either the time the
                    data was generated, or its position within a stream.
                    Data that does not arrive within the deadline cannot
                    be used, and therefore should not be sent. Deadlines
                    vary depending on the latency-tolerance of the
                    application: interactive applications have tight
                    latency bounds, while non-interactive applications are
                    less strict.
                </t>
                <t>
                    Applications must be able to specify the deadline for
                    the data they send, to prevent useless data from
                    being sent.
                </t>
            </section>
            <section anchor="PartialReliability" title="Partial reliability">
                <t>
                    The combination of a lossy best-effort network and
                    a timing &amp; deadlines service results in a partial
                    reliability service. Full reliability introduces
                    potentially unbounded latency: retransmissions are
                    required (given the limits of other recovery methods,
                    such as FEC) to correct for loss, and these
                    retransmissions themselves may be lost. Therefore, an
                    application that requires deadlines to be met can at
                    best benefit from partial reliability: data is
                    sent reliably while it is likely to meet their
                    deadlines.
                </t>
            </section>
            <section anchor="Dependencies" title="Dependencies">
                <t>
                    Partial reliability means that not all data that
                    is sent will be received. This means that it is
                    necessary to allow applications to expose dependency
                    information, and for a transport service to manage
                    these dependencies.
                </t>
                <t>
                    Data must not be sent if it relies on earlier
                    data that has not been successfully delivered. This
                    service must be provided in such a way that the
                    definition of what makes data useful to the
                    receiver is flexible.
                </t>
            </section>
            <section anchor="Messaging" title="Messaging">
                <t>
                    The combination of partial reliability and packet loss
                    means that application-level framing is required to
                    maximise the utility of each received packet. This
                    implies a message-oriented service to maintain
                    application data unit boundaries.
                </t>
                <t>
                    To minimise latency, messages are delivered to the
                    application in the order they arrive. Order introduces
                    latency when applied across a lossy IP network;
                    packets may be buffered waiting for earlier packet to
                    be retransmitted. ** should in-order delivery/sequencing
                    be something that applications can enable? **
                </t>
            </section>
            <section anchor="Multistreaming" title="Multistreaming">
                <t>
                    Messaging enables a multistreaming service. Many
                    applications are comprised of multiple streams, each
                    with their own characteristics with regards to the
                    other services listed. A multistreaming service would
                    allow these streams to be configured separately.
                </t>
            </section>
            <section anchor="Multipath" title="Multipath">
                <t>
                    Multiple paths often exist between hosts; a multipath
                    service is needed to allow applications to benefit
                    from this. This extends the multistreaming service:
                    different streams should be mapped to the most suitable
                    path, given the configuration of the stream and the
                    network conditions of the path.
                </t>
                <t>
                    Messaging is required to make optimal use of multiple
                    paths.
                </t>
            </section>
            <section anchor="CongestionControl" title="Congestion Control">
                <t>
                    Congestion control is an essential service, but one
                    algorithm does not fit all traffic types. The API
                    should enforce the need for a congestion control
                    algorithm (enforced by a transport circuit breaker?),
                    but allow the application to specify the specific 
                    algorithm used.
                </t>
            </section>
        </section>

        <section anchor="API" title="API">
            <t>
                What does the API that results from this list of services
                look like?
            </t>
        </section>

        <section anchor="Usage" title="Example Usage">
            <t>
                How would typical applications use this API?
            </t>
            <t>
                Want to show that while the list of transport services
                (and the API that follows) are focused on eliminating
                latency (or at least exposing it and making it optional),
                that latency-tolerant applications can use these primitives
                to get the delivery model they need.
            </t>
            <section anchor="HTTP1" title="HTTP/1.1">
                <t>
                    HTTP/1.1
                </t>
            </section>
            <section anchor="HTTP2" title="HTTP/2">
                <t>
                    HTTP/2
                </t>
            </section>
            <section anchor="RTP" title="Low-Latency Multimedia">
                <t>
                    RTP 
                </t>
            </section>
        </section>

        <section anchor="IANA" title="IANA Considerations">
            <t>This memo includes no request to IANA.</t>
        </section>

        <section anchor="Security" title="Security Considerations">
            <t></t>
        </section>
    </middle>

    <back>
    </back>
</rfc>